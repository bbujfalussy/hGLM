## A script to simulate response of a hLN model
## we generate both subthrehold response and spiking
## for adaptation and dynamic threshold the full vector is used instead of basis functions

## Here we use the constraint that synapses targeting the same subunit have IDENTICAL weights and time constants
## Each subunit has 7 parameters: 2 parameters for the excitatory synapses (Ww.e, Tau.e), 2 for the inhibitory ones (Ww.i, Tau.i) and 3 for the subunit: Jw coupling of subunit; Th threshold for nonlinearity; delay.t: filtering delay between the synapse and the soma
## the structure of the cell is defind by the parameter Jc and its inputs are given by Wc.e and Wc.i
## dTau.e and dTau.i: second time constant if we use double exponential synapses

source('../Utils/Spike_Basis.R', chdir = TRUE)

sim.hGLM.sp <- function(X=NULL, dt, pars, pars.spike, rseed=317, v.sub=NULL, ref.spikes=NULL, logpars=list(Jw=T, Tau=T, W=F), double=F, scale=2.8, verbose=F, Nrep=1){
## simulates the response of a hGLM to input spike trains
##
## Args: 
## 	X: NxT binary input matrix of presynaptic spikes; N: # of input neurons; T: # of timesteps; if missing, v.sub must be provided!
## 	dt: the time resolution of X in miliseconds
## 	pars: list of parameters for the SUBTHRESHOLD response - see sim.hGLM
## 	pars.spike: list of parameters for the SPIKING response
##			$beta: nonlinearity
##			$v.th: gain/basline
##			$w.th: basis weights for refractoryness
## 	ref.spikes: optional argument - the time of the output spikes to be provided; 
##		v.sub: subthreshold response - generated by sim.hGLM 
## 		these are the time of the threshold crossings and not the peaks! 
##		Nrep: number of repetitions to generate random spike output
## other arguments are passed to sim.hGLM:
## - logpars: parameters Tau, Jw and delay.t are strictly positive, so they can be defined by their log
## - double: logical; simple or double alpha kernels 
## - scale: if double kernels are used, the scaling factor between their time constants
## - verbose: regularisation details are provided

##
## Returns: 
## 	v: resp: vector of T, subthreshold response
## 	sp: vector of T; 0 everywhere, except at the threshold-crossings where it is 20-v

	if (is.null(v.sub)){
		if (is.null(X)) stop('input (X) or subthreshold Vm (v.sub) must be provided!')
		v.sub <- sim.hGLM(X, dt, pars, logpars=logpars, double=double, scale=scale,verbose=verbose)
	}

	### I need the subthreshold somatic response BEFORE the somatic nonlinearity
	if (logpars$Jw) Jw <- exp(pars$Jw[1]) else Jw <- pars$Jw[1]
	v0 <- pars$v0
	beta <- pars.spike$beta
	Th <- pars$Th[1]
	if (is.na(Th)) lin.soma <- T else lin.soma <- F
	if (lin.soma) y.soma <- (v.sub - v0)/ Jw else y.soma <- isigm((v.sub - v0)/ Jw, c=pars$Th[1])

	#####################################################
	## input-integration done, we start simulating the spikes 
	## and adding the effect of the spikes to the somatic membrane potential
	n.basis <- length(pars$W.ahp)
	n.basis.th <- length(pars.spike$w.th)
	basis.a <- gen.basis(Tmax=200, dt=dt, n.basis=n.basis, first=F, graphics=F)
	basis.t <- gen.basis(Tmax=200, dt=dt, n.basis=n.basis, first=T, graphics=F)
	basis.t <- basis.t[1:n.basis.th,] # we use 1-8 basis functions
	y.adapt <- as.vector(pars$W.ahp %*% basis.a) # we add this to the somatic input
	v.th <- as.vector(pars.spike$w.th %*% basis.t) # we add to the somatic threshold

	L.adapt <-  length(y.adapt)
	L <- length(v.sub)
	LL <- L + L.adapt
	
	if (is.null(ref.spikes)) {
		add.spikes <- T
	} else {
		if (Nrep > 1) {
			warning('Nrep should be 1 if reference spikes are provided')
			Nrep <- 1
		}
		add.spikes <- F # spike times are provided!
	}

	spikes <- matrix(0, Nrep, L) # the indexes of the spikes to be generated - we need extra L.self for the past spikes!
	v.soma <- matrix(NA, Nrep, L) # the somatic vm with the spikes
	if (add.spikes == F){
		spikes[1,round(ref.spikes/dt)] <- 60
	}

	for (i.rep in 1:Nrep){
		set.seed(rseed + i.rep)
		y.soma.adapt <- c(y.soma, rep(0, L.adapt)) # input + adaptation
		v.T <- rep(pars.spike$v.th, LL) # threshold
	
		for (i in 1:L){
			if (lin.soma) v.t <- Jw * y.soma.adapt[i] + v0 else v.t <- Jw * sigm(y.soma.adapt[i], c=Th) + v0
			v.soma[i.rep,i] <- v.t			
	
			# probability of spiking
			if (add.spikes & (i<L)){
				r.t <- exp(beta * (v.t - v.T[i])) * dt / 1000 # Hz
				p.silence.t <- exp(-r.t)
				if (p.silence.t < runif(1)) spikes[i.rep,i] <-  20 - v.soma[i.rep,i] # we add a spike 
			}
			# spiking causes adaptation and threshold dynamics
			
			if ((spikes[i.rep,i] > 0) & (i < L)){ # there is a spike!
		
				# spiking triggers adaptation
				y.soma.adapt[(i+1):(i+L.adapt)] <- y.soma.adapt[(i+1):(i+L.adapt)] + y.adapt
			
				# spiking triggers changes in the threshold
				v.T[(i+1):(i+L.adapt)] <- v.T[(i+1):(i+L.adapt)] + v.th
			}
		}
	}
	# spikes <- spikes[-(1:L.self)]
	resp <- list(v=v.soma, sp=spikes)
}

